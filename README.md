## 세션과 쿠키 학습을 위한 리포지토리

### 이론
#### (1) 세션 방식의 인증
1. 클라이언트의 상태를 유지하는데 사용하는 세션과 쿠키
2. 최초의 stateless 서버는 클라이언트의 상태를 저장하지 않고, 순순하게 정적 데이터를 응답해주는 목적으로 사용했다.
3. 상태를 저장할 필요를 느끼고, 세션과 쿠키를 도입해 클라이언트의 첫 요청에 서버는 세션ID를 생성해 서버의 세션 저장소에 저장하고, 응답헤더에 set-cookie 세션 ID를 담아서 클라이언트에 전달한다.
4. 2번째 요청부터 클라이언트 브라우저의 쿠키영역에 저장된 쿠키를 요청 헤더에 담아서 전달한다.
5. 서버에서 세션을 저장해야하는 stateful 서버는 세션을 관리해야하는 단점이 존재한다.

#### (2) 토큰 방식의 인증
1. 세션 방식의 인증의 단점을 해결하기 위한, 토큰 방식 인증 중 하나인 JWT을 이용한 stateless 서버가 등장했다. 
7. 세션과 쿠키는 프로토콜에 의한 자동 동작으로, 클라이언트의 상태를 저장하는 stateful 서버가 기본값이다.
8. 따라서 JWT을 이용하는 서버로 바꾸기 위해서는, 세션을 사용하지 않는다는 설정을 별도로 지정해줘야 한다.
9. 세션영역의 데이터는 Key:value형태로 데이터를 저장하는데, 해당 데이터에 정보를 저장할 경우 신중하게 처리해야한다.
10. 이는 세션 식별자 쿠키인 JSESSIONID를 저장할 경우 탈취당하지 않도록 관리가 필요하기 때문이다.
11. 이를 위해 스프링에서는 JSESSIONID를 HTTPONLY가 기본값으로 설정되어 자바스크립트에서 접근이 불가능하도록 설정되어있다.

#### (3) 동일 출처 정책을 통한 CORS 공격 방지
1. CORS 정책은 리소스를 들고 있는 서버가 자바스크립트 공격자에게 자원을 주지 않도록 CORS 공격을 방지하기 위한 정책이다.
2. 프론트엔드와 백엔드는 서로 다른 도메인을 사용해서 CORS 공격을 방지해야한다.
2. 이는 웹 브라우저에 적용된, 웹 보안 기술 중 하나인 동일 출처 정책에 따라, 스크립트 언어로 다른 도메인으로부터 리소스를 가져오는 것을 방지한다.
3. 백엔드와 프론트엔드가 같은 도메인을 사용하면, 백엔드에서 보내는 응답은 브라우저에서 처리하지 않기 때문에, 동일 출처 정책이 적용되지 않는다.
4. 같은 도메인의 경우, HTTP 응답으로 전송되는  백엔드 응답 헤더에 CORS 헤더를 포함하지 않기 때문이다.
5. 이는 보안 취약점이 존재할 가능성이 존재하므로, 서로 다른 도메인을 사용하여 동일 출처 정책을 적용해야 한다.
6. @CrossOrigin을 이용하는 어노테이션 방식, Filter를 이용하는 방식, 설정 클래스를 이용하는 방식으로 허용할 도메인을 추가해 적용 가능하다.
7. 내부적으로, 응답 헤더에 Access-Control-Allow-Origin를 추가해 브라우저에게 허용할 사이트인지 아닌지 알려준다.
8. 따라서 이러한 로직으로 동작하기 때문에, 모든 자바스크립트 요청이 아니라 브라우저를 통한 자바스크립트 요청만 거부될 수 있다는 것을 알 수 있다. (Node.js의 요청은 거부 불가)
9. 서버가 브라우저에게 허용할 요청과 거부할 요청을 알려주는 방식이다.

#### (4) XSS(Corss-Site Scripting) 공격 [본인 사이트에서 공격하는 방식]
1. 저장형 XSS : 악성 스크립트가 서버에 저장돼 해당 페이지에 방문한 모든 사용자에게 영향을 미침
2. 반사형 XSS : 악성 스크립트가 사용자의 입력 값으로 생성돼, 해당 페이지 방문한 모든 사용자에게 영향을 미침
3. 따라서, XSS 공격 방지를 위해서는 입력 값 검증과 출력 값 인코딩이 제대로 이루어져야 한다.
4. 일반적으로 타임리프 라이브러리로 HTML 엘리먼트르르 안전하게 이스케이프하거나 스프링 시큐리티로 필터링을 통해 인증 및 권한을 부여하는 방식으로 적용한다.

#### (5) CSRF(Cross-Site Request Forgery) 공격 [타 사이트에서 공격하는 방식]
1. 공격자가 인증된 사용자 권한을 이용해 악의적인 요청을 전송함으로써  사용자의 권한을 무단으로 사용하는 공격
2. 페이지 방문시마다 CSRF 토큰을 발급해 CSRF 공격을 방지한다.
3. 내부적으로 서버에서 CSRF 토큰의 유효성을 검사하고 일치하는 경우에만 요청을 처리하는 방식으로 공격자가 위조한 요청을 거부한다. 

#### (6) CSRF와 XSS의 차이


### 실습
#### 예외처리
1. NullPointerException 처리를 대신해주는 Optional 타입을 사용해야한다.
2. 쿼리메서드의 경우 단순한 쿼리만 작성이 가능하므로, 웬만하면 JPQL을 이용해 쿼리를 작성하는 연습이 필요하다.
3. JPQL을 이용한 쿼리 작성시 @Query 어노테이션을 이용하며, 이름 파라미터로 작성한 파라미터는 @Param을 이용해 파라미터로 전달해준다.
4. 예외 처리의 경우 RuntimeException을 상속하고, @RestControllerAdvice를 붙여 커스텀 예외클래스를 작성하고, ExceptionHandler 클래스에서 예외처리를 공통적으로 처리하도록 한다.
5. 예외처리 메서드의 경우 @ExceptionHandler의 속성에 처리하고자 하는 예외를 명시해 해당 예외 발생시 모두 해당 메서드에서 처리하도록 설정한다.
6. 리턴타입은 ResponseEntity<>로 JSON으로 응답객체에 에러메시지와 상태코드를 전달한다.

#### 모델
1. 모델의 경우 DTO를 작성하는데 요청 DTO에 연관된 DTO를 내부클래스로 작성하는 것이 좋다.
2. 이는 UserRequest.JoinDto, UserRequest.LoginDto와 같이 접근이 가능해지기 때문이다.
3. 또한, DTO가 Insert, Update와 같이 쓰기가 필요한 DTO라면 toEntity 메서드를 작성해 Builder 패턴을 이용해 해당 메서드 호출시 초기화가 가능하도록 작성하는 것이 좋다.
4. Java16에서 등장한 레코드의 경우 기존의 데이터 불변객체보다 간편하게 작성이 가능하다.
5. 레코드 객체는 데이터 저장만을 위한 클래스 작성시 사용할 수 있다.

#### 컨트롤러
##### (1) 회원등록
1. DI는 생성자 주입과 메서드 주입 모두 가능하며, 생성자 주입의 경우 스프링 컨테이너에서 주입해주며 메서드 주입의 경우 디스패처서블릿이 리플렉션을 이용해 주입해준다.
2. REST CONTROLLER에서는 영속화 객체를 메시지 컨버터가 JSON으로 해당 객체의 Getter를 호출해 직렬화한다.
3. 이 같은 로직은, 해당 객체가 지연로딩으로 수행될 경우 양방향 맵핑이 되어있으면, 무한 순환참조가 발생가능하므로 주의해야한다.
4. 리포지토리의 save로 비영속객체를 전달해 영속화 시키는데, 해당 비영속 객체는 DTO에서 작성한 toEntity를 이용해 객체를 생성한다.
5. Optional 객체로 감싼 User 객체를 처리하는 정석 코드 (1) if-present : setAttribute-get (2) else-throw

##### (2) 인증
1. 인증 체크하는 메서드 - 세션에 loginUser 키를 가진 데이터가 있는지 확인해 인증 체크를 수행한다.
2. 세션 키는 JSESSIONID로 탈취당하면 안되는 키이므로, 탈취당하면 민감한 정보를 해킹당할 수 있다.
3. JSESSIONID는 HTTPONLY 설정이 되어있어서 JS로는 해킹이 불가능하다.
4. 인증 체크하는 로직을 인터셉터로 분리해, 인증이 필요한 URL 패턴에 중복코드를 제거하고, 공통로직으로 처리하도록 한다.
10. 인터셉터는 디스패처서블릿 이전에 전역적으로 체크하는 필터와 다르게, 컨트롤러의 특정 메서드 전후를 제어한다.
11. 따라서, DB 접근이 가능하며 컨트롤러의 메서드 단에서 필터링 역할을 수행한다.
12. 메서드 직전에 필터링하는 메서드 : preHandle -> 리턴값에 따라 메서드 수행 여부를 결정
13. 인터셉터 작성 후에는, WebMvcConfigurer를 상속한 설정 클래스에 url 패턴과 함께 인터셉터 레지스트리에 등록
14. 인터셉터로 중복 코드를 제거하면, 컨트롤러가 단순해지고 핵심 로직에만 집중해서 개발할 수 있다.

##### (3) 인증과 권한
1. 인증을 통해 확인한 사용자가 요청한 자원에 접근할 수 있는 권한이 있는지 여부를 체크한다.
2. 요청한 자원과 인증된 사용자 정보를 비교해 자원에 접근 가능한 권한을 가진 사용자인지 체크한다.
3. 일반적으로는 ROLE을 통해 먼저 체크하지만, 여기서는 접근하는 자원과 인증한 사용자가 동일한지 체크한다.
4. 또한, 주소로 전달되는 데이터는 조작이 가능한 신뢰할 수 없는 데이터이므로, 검증과정이 필수적으로 요구된다.